#!/usr/bin/env perl6
use File::Temp;

my %typemap = 
  'int' => 'int32',
  'unsigned' => 'int32',
  'unsigned int' => 'int32',
  '_Bool' => 'int32',
  'long' => 'int32',
  'unsigned long' => 'int32',
  'short' => 'int16',
  'char' => 'int8',
  'char*' => 'Str',
  'void*' => 'OpaquePointer',
my %typedef;

sub MAIN($module-name!,$lib-name!,$h-file!,$c-preprocessor='cpp $IN $OUT',$c-compiler='gcc -o $EXE $SRC') {

    my $h-text = $h-file.IO.slurp or die "Can't open h-file $h-file";
    $h-text ~~ s:g/'\\'\n//; #::

    my $cpp-output = preprocess-file($h-file,$c-preprocessor);
    my $cpp-parse = parse-cpp($cpp-output);
    die $cpp-parse.perl;

    for $cpp-output.comb(/^^ typedef \s+ [<[\w\*]>+ \s+]* \w+ \s+ \w+ ';'/) {
        if /typedef \s+ ([<[\w\*]>+ \s+]* \w+) \s+ (\w+) / {
            my $def = $0;
            my $new-type = $1;
            $def = %typedef{$def} while %typedef{$def};
            %typedef{$new-type} = $def;
            $*ERR.say("typedef $new-type -> $def");
            if (%typemap{$def}) {
                %typemap{$new-type} = %typemap{$def};
                $*ERR.say("Added type $new-type -> %typemap{$def}");
            }
        }
    }

    my $constant-sect = make-constant-sect($h-text,$h-file,$c-compiler);

    my ($func-sect,$unknown-types) = make-func-sect($cpp-output);

    my $type-sect = make-type-sect($cpp-output,$unknown-types);

    say $_ for
        "module $module-name;",
        'use NativeCall;',
        "# Automatically generated by h-to-pm by parsing $h-file and using the c preprocessor and compiler",
        '',
        '# Constants',
        $constant-sect,
        '# Structs',
        $type-sect,
        '# Functions',
        "constant LIBNAME = '$lib-name';",
        $func-sect;

}

sub preprocess-file($h-file,$c-preprocessor) {
    my ($cpp-out-file) = tempfile(:suffix<.c>);
    my @cpp-command = make-command-from-template($c-preprocessor,{IN=>$h-file,OUT=>$cpp-out-file});
    #say $*ERR,"Precompiling: {@cpp-command}";
    run(@cpp-command) or die;
    my @lines;
    my $source-file = '';
    for $cpp-out-file.IO.lines -> $line {
        # We must only include the lines from the original .h file, not included files
        if $line ~~ /^ '#'/ && $line ~~ / '/' (\w+ '.h') '"'/ { #"
            $source-file = $0;
        } elsif $source-file eq $h-file.path.basename {
            push @lines, $line;
        }
    }
    return @lines.join("\n");
}

grammar PreprocessedCHeader {
    rule TOP {
        ^
        <statement>*
        $
    }

    token statement {
          <typedef>
        | <struct>
        | <enum>
        | <function>
        | <pragma>
    }
    
    rule pragma { '#' \N+ }

    rule typedef {
        'typedef'
        [ <struct> | <type> ]
        <name-or-cb>
        <params>?
        ';'
    }

    rule struct {
        'struct'
        <name>
        [
            '{'
            [<union> | <vardef>]*
            '}'
        ]?
        ';'
    }

    rule union {
        'union' '{'
        <vardef>*
        '}'
        <name>?
        ';'
    }

    rule vardef {
        <type> <names> ';'
    }

    rule type {
        'const'?
        ['signed' | 'unsigned']?
        <typename>?
        [<pointer> | <array>]?
    }

    rule typename {
        ['long long' | \w+]
    }

    token pointer { '*' }
    rule array { '[' [\d+]+ % ',' ']' }

    rule names { <name-or-cb>+ % ',' }

    rule name-or-cb {
        [ [ '(' '*'? <name> ')' ] | <name> ]
    }

    token name { [ \w+ | '...' ] }

    rule enum {
        'enum' <name> '{' <names> '}' ';'
    }

    rule function {
        'extern'?
        <type>
        <name>
        <params>?
        ';'
    }

    rule params {
        '('
            [ <type> <name>? ]+ % ','
        ')'
    }
}

sub parse-cpp($cpp-output2) {
    my $cpp-output = Q[
extern int wscrl (WINDOW *,int);
extern int wsetscrreg (WINDOW *,int,int);
];
    say($cpp-output);
    my $m = PreprocessedCHeader.parse($cpp-output);
    for $m<statement>.list -> $s {
        say $s.perl;
    }
    die;
}

sub make-command-from-template($tpl is copy,$vars) {
    $tpl ~~ s:g/'$'(\w+)/{$vars{$0} or die("unknown var $0")}/;  #::
    return $tpl.split(/\s+/);
}

sub make-constant-sect($h-text,$h-file,$c-compiler) {
    return '';
    my ($c_fn,$c_fh) = tempfile(:suffix<.c>);
    my ($exe_fn,$exe_fh) = tempfile;
    $exe_fh.close();
    $c_fh.close();
    my ($out_fn) = tempfile;

    my @cc-command = make-command-from-template($c-compiler,{EXE=>$exe_fn,SRC=>$c_fn});
    my $cc-command = @cc-command.join(' ') ~ ' > /dev/null 2>&1';

    my %constants;

    $*ERR.print("compiling small programs to find values of potential constants: ");
    for $h-text.split(/\n/).grep(/ ^ '#' \s* 'define' \s+ <[A..Z]><[A..Z0..9_]>+ \s+ <-[a..z]>+ $ /) -> $l {
        if $l ~~ /define \s+ (\w+)/ {
            my $name = $/[0].Str;
            $*ERR.print("$name ");
            my $c_doc = Q:qq{#include <$h-file>\nvoid main(void){printf("value:%d\\n",(int)$name);}};
            unlink($c_fn);
            $c_fh = open($c_fn, :w);
            $c_fh.print($c_doc);
            $c_fh.close();
            shell($cc-command);
            if $exe_fn.IO ~~ :e {
                my $result = qqx/$exe_fn/;
                if $result ~~ /'value:'(\d+)/ {
                    %constants{$name} = $0.Str;
                }
            }
        }
    }
    $*ERR.say(" done.");

    return %constants.pairs.sort(*.key).map({
        "constant {$_.key} is export = {$_.value};"
    }).join("\n");

}

sub make-func-sect($cpp-output) {
    my @funcs;
    my $missing-types = {};

    for $cpp-output.comb(/^^ \h* extern \s+ ['const' \s+]? [['unsigned' | 'struct'] \s+]? [\w+ \s+]? \w+ [\s* '*']? \s+ \w+ \s+ '(' <-[)]>* ');'/) -> $_ is copy {
        s:g/\s+/ /; #::
        if /extern \s+ $<returns>=(['const' \s+]? [['unsigned' | 'struct' ] \s+ ]? [\w+ \s+]? \w+ [\s* '*']?) \s+ $<name>=(\w+) \s* '(' \s* $<params>=(<-[\)]>*) \s* ')'/ {
            push @funcs, "#$_";
            my $name = $<name>.Str;
            my $returns = fixtypes($<returns>.Str,$missing-types);
            my $params = fixtypes($<params>.Str,$missing-types);
            push @funcs, "sub {$name}($params) returns $returns is export is native(LIBNAME);";
        }
    }
    return (@funcs.join("\n"), $missing-types);
}

sub fixtypes($str is copy,$missing-types) {
    my @types;
    $str ~~ s:g/\s+\*/\*/; #::
    $str ~~ s/^\s+//;
    $str ~~ s/\s+$//;
    return '' if $str eq 'void';
    for $str.split(/ \s* ',' \s*/) -> $s is copy {
        $s ~~ s/^const\s*//;
        my $type = %typemap{$s};
        if !$type {
            my $name-removed = $s.subst(/\s*\w+$/,'');
            if %typemap{$name-removed} {
                $type = %typemap{$name-removed};
            } else {
                $type = add-missing-type($s,$missing-types);
            }
        }
        push @types, $type;
    }
    return ~~@types.join(',');
}

sub add-missing-type($type,$missing-types) {
    if $type ~~ /\*$/ { # Pointer
        my $ptype = $type.subst(/\*$/,'');
        if %typemap{$ptype} {
            #$*ERR.say("$type is pointer to %typemap{$ptype}");
            %typemap{$type} = "CArray[%typemap{$ptype}]";
            return %typemap{$type};
        } else {
            #$*ERR.say("We're missing pointer type $ptype");
            $missing-types{$ptype} = 1;
            return "$ptype";
        }
    } else {
        #$*ERR.say("We're missing type $type");
        return "$type";
    }
}

sub make-type-sect($cpp-output,$types) {
    my %struct-typedefs;
    my %structs;
    for $cpp-output.comb(/^^ [typedef \s+]? struct [\s+ \w+]? \s* '{' \s* .*? \n '}' \s* [\w+ \s*]? ';'/) {
        if (/[typedef \s+]? struct [\s+ $<struct>=(\w+)]? \s* '{' \s* $<body>=(.*?) \n '}' \s* [$<typedef>=(\w+) \s*]? ';'/) {
            my $struct = $/<struct>;
            my $body = $/<body>;
            my $typedef = $/<typedef>;
            $struct = $typedef unless $struct;
            my @body;
            for $body.comb(/\s* [\w+ % \s+]+ [\w+ % [',' \s*]] \s* ';'/) {
                if (/$<type>=([\w+ % \s+]+) $<names>=([\w+ % [',' \s*]]) \s* ';'/) {
                    $*ERR.say("attr $/<names> : $/<type>");
                    my $type = $/<type>;
                    @body.push($_ => $type) for $/<names>.split(/',' \s*/);
                }
            }
            %structs{$struct} = [@body];
            %struct-typedefs{$typedef} = $struct if $typedef;
        }
    }

    my @classes;
    for $types.keys -> $type {
        $*ERR.say("checking for type $type");
        my $def;
        $def = %struct-typedefs{$type} if %struct-typedefs{$type};
        $def = $type if %structs{$type};
        if $def {
            $*ERR.say("We have type $type!");
            @classes.push((
                "class $type is repr(CStruct) \{",
                %structs{$def}.map({
                    "  has {$_.value} \$!{$_.key};"
                }),
                '}'
            ));
        }
    }
    return @classes.join("\n");
}

